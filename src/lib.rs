//! A program that generates a wav file with randomly generated music.
//! The music is generated by randomly selecting notes from a scale and
//! randomly selecting the duration of each note (one of 1/16, 1/8, 1/4, 1/2, and whole notes).
//! The program uses the `hound` crate to generate the wav file, so we
//! can compile for the web.

use std::{
    ops::{Add, AddAssign},
    path::Path
};

pub trait Timed {
    fn duration(&self) -> f32;
}

impl<T> Timed for Vec<T> where T: Timed {
    fn duration(&self) -> f32 {
        self.iter().map(|t| t.duration()).sum()
    }
}

#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Scale {
    /// The major scale is a diatonic scale with a specific pattern of whole and half steps.
    #[default]
    Major,
    /// The natural minor scale is very similar to the major scale,
    /// but with a flatted third, sixth, and seventh.
    Minor,
    /// The major blues scale is a subset of the major scale.
    MajorBlues,
    /// The minor blues scale is a subset of the minor scale.
    /// It is similar to the minor pentatonic scale, but with an added note.
    MinorBlues,
    /// The major pentatonic scale is a subset of the major scale.
    MajorPentatonic,
    /// The minor pentatonic scale is a subset of the minor scale.
    MinorPentatonic,
    /// The chromatic scale is a scale that includes all twelve notes.
    Chromatic,
    /// The whole tone scale is a scale that includes only whole steps.
    WholeTone,
    /// The octatonic scale is a scale that alternates whole and half steps.
    Octatonic,
    /// The diminished scale is a scale that alternates whole and half steps.
    Diminished,
}


/// Get an iterator of note types for a given scale.
/// The iterator will loop through the notes in the scale indefinitely.
impl Scale {
    pub fn notes(&self, key: NoteType) -> impl Iterator<Item = NoteType> {
        let note_offsets = self.note_offsets();
        let key = i32::from(key);
        note_offsets.into_iter().map(move |offset| {
            let note = NoteType::from(offset + key);
            note
        }).cycle()
    }

    fn note_offsets(&self) -> Vec<i32> {
        match self {
            Scale::Major => vec![0, 2, 4, 5, 7, 9, 11],
            Scale::Minor => vec![0, 2, 3, 5, 7, 8, 10],
            Scale::MajorBlues => vec![0, 2, 3, 4, 7, 9],
            Scale::MinorBlues => vec![0, 3, 5, 6, 7, 10],
            Scale::MajorPentatonic => vec![0, 2, 4, 7, 9],
            Scale::MinorPentatonic => vec![0, 3, 5, 7, 10],
            Scale::Chromatic => vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            Scale::Octatonic => vec![0, 2, 3, 5, 6, 8, 9, 11],
            Scale::Diminished => vec![0, 2, 3, 5, 6, 8, 9, 11],
            Scale::WholeTone => vec![0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22],
        }
    }
}


#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum NoteType {
    #[default]
    A,
    ASharp,
    B,
    C,
    CSharp,
    D,
    DSharp,
    E,
    F,
    FSharp,
    G,
    GSharp,
    Rest,
}

impl NoteType {
    pub fn dominant(&self) -> NoteType {
        *self + 7
    }

    pub fn to_offset(&self) -> i32 {
        i32::from(*self)
    }

    pub fn from_offset(offset: i32) -> NoteType {
        NoteType::from(offset)
    }
}

impl From<i32> for NoteType {
    fn from(note: i32) -> NoteType {
        match note % 12 {
            0 => NoteType::C,
            1 => NoteType::CSharp,
            2 => NoteType::D,
            3 => NoteType::DSharp,
            4 => NoteType::E,
            5 => NoteType::F,
            6 => NoteType::FSharp,
            7 => NoteType::G,
            8 => NoteType::GSharp,
            9 => NoteType::A,
            10 => NoteType::ASharp,
            11 => NoteType::B,
            _ => NoteType::Rest,
        }
    }
}

impl From<u8> for NoteType {
    fn from(note: u8) -> NoteType {
        NoteType::from(note as i32)
    }
}

impl From<NoteType> for i32 {
    fn from(note: NoteType) -> i32 {
        match note {
            NoteType::C => 0,
            NoteType::CSharp => 1,
            NoteType::D => 2,
            NoteType::DSharp => 3,
            NoteType::E => 4,
            NoteType::F => 5,
            NoteType::FSharp => 6,
            NoteType::G => 7,
            NoteType::GSharp => 8,
            NoteType::A => 9,
            NoteType::ASharp => 10,
            NoteType::B => 11,
            NoteType::Rest => -1,
        }
    }
}

impl From<NoteType> for u8 {
    fn from(note: NoteType) -> u8 {
        i32::from(note) as u8
    }
}

impl Add<i32> for NoteType {
    type Output = NoteType;

    fn add(self, n: i32) -> NoteType {
        NoteType::from(i32::from(self) + n)
    }
}

impl AddAssign<i32> for NoteType {
    fn add_assign(&mut self, n: i32) {
        *self = NoteType::from(i32::from(*self) + n);
    }
}

/// A note with an octave.
#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct Note {
    /// The note.
    note: NoteType,
    /// The octave of the note.
    octave: u8,
}

impl Note {
    /// Create a new note.
    pub fn new(note: NoteType, octave: u8) -> Note {
        Note { note, octave }
    }

    pub fn with_duration(&self, duration: f32) -> TimedNote {
        TimedNote::new(self.note, self.octave, duration)
    }

    /// Get the frequency of the note.
    /// The frequency is calculated as 440 * 2^(n/12), where n is the number of half steps from A4.
    pub fn frequency(&self) -> f32 {
        let n = match self.note {
            NoteType::C => 0,
            NoteType::CSharp => 1,
            NoteType::D => 2,
            NoteType::DSharp => 3,
            NoteType::E => 4,
            NoteType::F => 5,
            NoteType::FSharp => 6,
            NoteType::G => 7,
            NoteType::GSharp => 8,
            NoteType::A => 9,
            NoteType::ASharp => 10,
            NoteType::B => 11,
            NoteType::Rest => return 0.0,
        };
        let n = n + 12 * (self.octave as i32 - 4);

        let a4 = 440.0;
        a4 * 2.0_f32.powf((n as f32 - 9.0) / 12.0)
    }
}

impl Add<i32> for Note {
    type Output = Note;

    fn add(self, n: i32) -> Note {
        let note = self.note + n;
        let octave = self.octave + (i32::from(note) / 12) as u8;
        Note::new(note, octave)
    }
}

impl From<NoteType> for Note {
    fn from(note: NoteType) -> Note {
        Note::new(note, 4)
    }
}

impl<T> Add<T> for Note where T: Into<Note> {
    type Output = Chord;

    fn add(self, other: T) -> Chord {
        Chord::new(&[self, other.into()])
    }
}

/// A chord is a collection of notes.
#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct Chord([Option<Note>; 16]);

impl Chord {
    pub fn new(notes: &[Note]) -> Chord {
        let mut result = [None; 16];
        for (i, note) in notes.iter().enumerate() {
            result[i] = Some(*note);
        }
        Self(result)
    }

    pub fn major(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note.dominant(), octave),
            Note::new(note + 4, octave),
        ])
    }

    pub fn minor(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 3, octave),
            Note::new(note + 7, octave),
        ])
    }

    pub fn major7(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note.dominant(), octave),
            Note::new(note + 4, octave),
            Note::new(note + 7, octave),
        ])
    }

    pub fn minor7(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 3, octave),
            Note::new(note + 7, octave),
            Note::new(note + 10, octave),
        ])
    }

    pub fn augmented(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 4, octave),
            Note::new(note + 8, octave),
        ])
    }

    pub fn diminished(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 3, octave),
            Note::new(note + 6, octave),
        ])
    }

    pub fn dominant7(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note.dominant(), octave),
            Note::new(note + 4, octave),
            Note::new(note + 7, octave),
        ])
    }

    pub fn half_diminished7(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 3, octave),
            Note::new(note + 6, octave),
            Note::new(note + 10, octave),
        ])
    }

    pub fn diminished7(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 3, octave),
            Note::new(note + 6, octave),
            Note::new(note + 9, octave),
        ])
    }

    pub fn major6(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note.dominant(), octave),
            Note::new(note + 4, octave),
            Note::new(note + 9, octave),
        ])
    }

    pub fn suspended4(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 5, octave),
            Note::new(note + 7, octave),
        ])
    }

    pub fn suspended2(note: NoteType, octave: u8) -> Chord {
        Chord::new(&[
            Note::new(note, octave),
            Note::new(note + 2, octave),
            Note::new(note + 7, octave),
        ])
    }

    pub fn add_note(&mut self, note: Note) {
        for i in 0..16 {
            if self.0[i].is_none() {
                self.0[i] = Some(note);
                break;
            }
        }
    }

    pub fn with_duration(&self, duration: f32) -> TimedChord {
        TimedChord::from_chord(*self, duration)
    }

    pub fn notes(&self) -> impl Iterator<Item = Note> + '_ {
        self.0.iter().filter_map(|&note| note)
    }

    pub fn is_silent(&self) -> bool {
        self.0.iter().all(|note| matches!(note, None | Some(Note { note: NoteType::Rest, .. })))
    }
}

impl<T> Add<T> for Chord where T: Into<Chord> {
    type Output = Chord;

    fn add(mut self, other: T) -> Chord {
        let other = other.into();
        for note in other.notes() {
            self.add_note(note);
        }
        self
    }
}

impl<T> AddAssign<T> for Chord where T: Into<Chord> {
    fn add_assign(&mut self, chord: T) {
        let chord = chord.into();
        for note in chord.notes() {
            self.add_note(note);
        }
    }
}

impl From<TimedChord> for Chord {
    fn from(timed_chord: TimedChord) -> Chord {
        timed_chord.chord
    }
}

impl From<Note> for Chord {
    fn from(note: Note) -> Chord {
        Chord::new(&[note])
    }
}

impl Add<i32> for Chord {
    type Output = Chord;

    fn add(self, n: i32) -> Chord {
        let notes = self.notes().map(|note| note + n).collect::<Vec<_>>();
        Chord::new(&notes)
    }
}

impl From<TimedNote> for Chord {
    fn from(note: TimedNote) -> Chord {
        Chord::new(&[Note::from(note)])
    }
}

impl IntoIterator for Chord {
    type Item = Note;
    type IntoIter = std::vec::IntoIter<Note>;

    fn into_iter(self) -> Self::IntoIter {
        self.notes().collect::<Vec<_>>().into_iter()
    }
}

/// A timed chord is a chord with a duration.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct TimedChord {
    chord: Chord,
    /// The duration of the chord in beats.
    duration: f32,
}

impl TimedChord {
    pub fn new(notes: &[Note], duration: f32) -> TimedChord {
        TimedChord { chord: Chord::new(notes), duration }
    }

    pub fn from_chord(chord: Chord, duration: f32) -> TimedChord {
        TimedChord { chord, duration }
    }

    pub fn contains(&self, note: Note) -> bool {
        self.chord.notes().any(|n| n == note)
    }

    pub fn add_note(&mut self, note: Note) {
        self.chord.add_note(note);
    }

    pub fn notes(&self) -> impl Iterator<Item = Note> + '_ {
        self.chord.notes()
    }
}

impl<T> Add<T> for TimedChord where T: Into<Chord> {
    type Output = TimedChord;

    fn add(mut self, chord: T) -> TimedChord {
        let chord = chord.into();
        for note in chord.notes() {
            self.add_note(note);
        }
        self
    }
}

impl<T> AddAssign<T> for TimedChord where T: Into<Chord> {
    fn add_assign(&mut self, chord: T) {
        let chord = chord.into();
        for note in chord.notes() {
            self.add_note(note);
        }
    }
}

impl Add<i32> for TimedChord {
    type Output = TimedChord;

    fn add(self, n: i32) -> TimedChord {
        let chord = self.chord + n;
        TimedChord { chord, duration: self.duration }
    }
}

impl From<TimedNote> for TimedChord {
    fn from(note: TimedNote) -> TimedChord {
        let duration = note.duration();
        TimedChord::new(&[note.into()], duration)
    }
}

impl IntoIterator for TimedChord {
    type Item = Note;
    type IntoIter = std::vec::IntoIter<Note>;

    fn into_iter(self) -> Self::IntoIter {
        self.notes().collect::<Vec<_>>().into_iter()
    }
}

impl Timed for TimedChord {
    fn duration(&self) -> f32 {
        self.duration
    }
}

impl Default for TimedChord {
    fn default() -> TimedChord {
        TimedChord {
            chord: Chord::default(),
            duration: 1.0,
        }
    }
}

/// A timed note is a note with a duration.
#[derive(Debug, Clone, Copy)]
pub struct TimedNote {
    note: Note,
    /// The duration of the note in beats.
    duration: f32,
}

impl TimedNote {
    pub fn new(note: NoteType, octave: u8, duration: f32) -> TimedNote {
        TimedNote { note: Note::new(note, octave), duration }
    }

    pub fn from_note_type(note: NoteType, duration: f32) -> TimedNote {
        TimedNote { note: Note::new(note, 4), duration }
    }

    pub fn note(&self) -> Note {
        self.note
    }
}

impl Add<i32> for TimedNote {
    type Output = TimedNote;

    fn add(self, n: i32) -> TimedNote {
        let note = self.note.note + n;
        let octave = self.note.octave + (i32::from(note) as u8 / 12) as u8;
        TimedNote { note: Note::new(note, octave), duration: self.duration }
    }
}

impl Timed for TimedNote {
    fn duration(&self) -> f32 {
        self.duration
    }
}

impl From<TimedNote> for Note {
    fn from(timed_note: TimedNote) -> Note {
        timed_note.note
    }
}

pub struct Song {
    melody: Vec<TimedNote>,
    harmony: Vec<TimedNote>,
    chords: Vec<TimedChord>,
    // Beats per minute.
    tempo: f32,

    loop_track: bool,
}

impl Song {
    pub fn new(melody: Vec<TimedNote>, chords: Vec<TimedChord>, bpm: f32, loop_track: bool) -> Song {
        Song { melody, harmony: vec![], chords, tempo: bpm, loop_track }
    }

    pub fn with_harmony(mut self, harmony: Vec<TimedNote>) -> Self {
        self.harmony = harmony;
        self
    }

    /// Combine the notes from the melody and chords into a single song.
    fn get_notes_at_beat(&self, beat: f32) -> Option<Chord> {
        let mut notes = Chord::default();
        // Find the time in the melody.
        let mut scanned_beat = 0.0;
        let mut found_music = false;
        for note in &self.melody {
            if scanned_beat + note.duration() > beat {
                // println!("Found melody note {:?}={} at beat {}", note, note.duration(), beat);
                notes += *note;
                found_music = true;
                break;
            }
            scanned_beat += note.duration();
        }
        
        scanned_beat = 0.0;
        for note in &self.harmony {
            if scanned_beat + note.duration() > beat {
                // println!("Found melody note {:?}={} at beat {}", note, note.duration(), beat);
                notes += *note;
                found_music = true;
                break;
            }
            scanned_beat += note.duration();
        }

        // Now do the same for the chords
        scanned_beat = 0.0;
        for chord in &self.chords {
            if scanned_beat + chord.duration() > beat {
                // println!("Found chord {:?} at beat {}", chord, beat);
                notes += *chord;
                found_music = true;
                break;
            }
            scanned_beat += chord.duration();
        }

        if !found_music {
            None
        } else {
            Some(notes)
        }
    }

    #[cfg(feature = "playback")]
    pub fn play(&self) {
        // Setup the sine wave.
        use rodio::source::{SineWave, Source};
        use rodio::{dynamic_mixer, OutputStream, Sink};
        use std::time::Duration;


    
        let mut beat = 0.0;
        let duration = 60.0 / self.tempo;
        let (_stream, stream_handle) = OutputStream::try_default().unwrap();
        let sink = Sink::try_new(&stream_handle).unwrap();

        loop {
            let chord = self.get_notes_at_beat(beat);
            match chord {
                Some(chord) => {
                    let (controller, mixer) = dynamic_mixer::mixer::<f32>(4, 44_100);
                    for note in chord {
                        let mut source = SineWave::new(note.frequency())
                            .take_duration(Duration::from_secs_f32(duration));
                        source.set_filter_fadeout();
                        // let source = source.low_pass(1000);
                        controller.add(source.amplify(0.15));
                    }

                    let mixer = mixer.fade_in(Duration::from_secs_f32(0.001));

                    sink.append(mixer);

                    beat += duration;
                }
                None => {
                    if self.loop_track {
                        beat = 0.0;
                    } else {
                        break;
                    }
                },
            }
        }

        // sink.sleep(Duration::from_secs_f32(duration));
        sink.sleep_until_end();
    }

    fn pad_with_rests(&mut self) {
        // Find the shortest duration of the three.
        let shortest_duration = self.melody.duration().min(self.harmony.duration()).min(self.chords.duration());
        let melody_duration = self.melody.duration();
        let harmony_duration = self.harmony.duration();
        let chords_duration = self.chords.duration();
        if melody_duration < shortest_duration {
            self.melody.push(TimedNote::new(NoteType::Rest, 4, shortest_duration - melody_duration));
        }
        if harmony_duration < shortest_duration {
            self.harmony.push(TimedNote::new(NoteType::Rest, 4, shortest_duration - harmony_duration));
        }
        if chords_duration < shortest_duration {
            self.chords.push(TimedChord::new(&[Note::from(NoteType::Rest)], shortest_duration - chords_duration));
        }
    }

    pub fn save(&self, wav_file_path: &Path, cross_fade_duration_secs: f32, sample_generator: &dyn Fn(&Song, f32, f32, u16) -> Vec<f32>) -> Result<(), Box<dyn std::error::Error>> {
        // Setup the sine wave.
        use hound::{WavSpec, WavWriter};

        let sample_rate = 44_100 as f32;
        let channels = 2;
        let spec = WavSpec {
            channels,
            sample_rate: sample_rate as u32,
            bits_per_sample: 32,
            sample_format: hound::SampleFormat::Float,
        };
        let mut writer = WavWriter::create(wav_file_path, spec)?;
        for sample in sample_generator(self, sample_rate, cross_fade_duration_secs, channels) {
            writer.write_sample(sample)?;
        }


        writer.finalize()?;

        Ok(())
    }

    /// Generate a vector of frequency samples for the song using sine waves.
    /// The samples are generated at the given sample rate, it's recommended to use 44_100 Hz,
    /// and a cross fade duration of 0.012. The cross fade duration is the duration in seconds
    /// that the frequency transitions are smoothed out.
    pub fn generate_frequency_samples_sine_wave(&self, sample_rate: f32, cross_fade_duration_secs: f32, channels: u16) -> Vec<f32> {
        use std::f32::consts::PI;
        let mut samples = vec![];

        let mut beat = 0.0;
        let duration = 60.0 / self.tempo;
        loop {
            let chord = self.get_notes_at_beat(beat);
            match chord {
                Some(chord) => {
                    let frequencies = chord.notes().map(|note| note.frequency()).collect::<Vec<_>>();

                    // Smooth frequency transitions for each sample by fading in and out.
                    let fade = cross_fade_duration_secs;
                    for n in 0..(duration * sample_rate * channels as f32) as usize {
                        let mut sample = 0.0;
                        for freq in &frequencies {
                            let t = n as f32 / (duration * sample_rate * channels as f32);
                            let fade_in = (t / fade).min(1.0);
                            let fade_out = ((1.0 - t) / fade).min(1.0);
                            let fade = fade_in.min(fade_out);
                            sample += (n as f32 * freq * 2.0 * PI / sample_rate / channels as f32).sin() * fade;
                        }
                        sample /= frequencies.len() as f32;
                        // writer.write_sample(sample)?;
                        samples.push(sample);
                    }
                    

                    beat += duration;
                }
                None => break,
            }
        }

        samples
    }

    pub fn generate_frequency_samples_square_wave(&self, sample_rate: f32, cross_fade_duration_secs: f32, channels: u16) -> Vec<f32> {
        use std::f32::consts::PI;
        let mut samples = vec![];

        let mut beat = 0.0;
        let duration = 60.0 / self.tempo;
        loop {
            let chord = self.get_notes_at_beat(beat);
            match chord {
                Some(chord) => {
                    let frequencies = chord.notes().map(|note| note.frequency()).collect::<Vec<_>>();

                    // Smooth frequency transitions for each sample by fading in and out.
                    let fade = cross_fade_duration_secs;
                    for n in 0..(duration * sample_rate * channels as f32) as usize {
                        let mut sample = 0.0;
                        for freq in &frequencies {
                            let t = n as f32 / (duration * sample_rate * channels as f32);
                            let fade_in = (t / fade).min(1.0);
                            let fade_out = ((1.0 - t) / fade).min(1.0);
                            let fade = fade_in.min(fade_out);
                            // sample += (n as f32 * freq * 2.0 * PI / sample_rate / channels as f32).sin() * fade;
                            // Use square wave instead of sine wave.
                            sample += (n as f32 * freq * 2.0 * PI / sample_rate / channels as f32).sin().signum() * fade;
                        }
                        sample /= frequencies.len() as f32;
                        // writer.write_sample(sample)?;
                        samples.push(sample);
                    }
                    

                    beat += duration;
                }
                None => break,
            }
        }

        samples
    }

    pub fn generate_frequency_samples_sawtooth_wave(&self, sample_rate: f32, cross_fade_duration_secs: f32, channels: u16) -> Vec<f32> {
        use std::f32::consts::PI;
        let mut samples = vec![];

        let mut beat = 0.0;
        let duration = 60.0 / self.tempo;
        fn sawtooth_wave(freq: f32, n: usize, sample_rate: f32, channels: u16) -> f32 {
            let t = n as f32 / (sample_rate * channels as f32);
            let sawtooth = (t * freq * PI).fract() * 2.0 - 1.0;
            sawtooth
        }

        loop {
            let chord = self.get_notes_at_beat(beat);
            match chord {
                Some(chord) => {
                    let frequencies = chord.notes().map(|note| note.frequency()).collect::<Vec<_>>();

                    // Smooth frequency transitions for each sample by fading in and out.
                    let fade = cross_fade_duration_secs;
                    for n in 0..(duration * sample_rate * channels as f32) as usize {
                        let mut sample = 0.0;
                        for freq in &frequencies {
                            let t = n as f32 / (duration * sample_rate * channels as f32);
                            let fade_in = (t / fade).min(1.0);
                            let fade_out = ((1.0 - t) / fade).min(1.0);
                            let fade = fade_in.min(fade_out);
                            // sample += (n as f32 * freq * 2.0 * PI / sample_rate / channels as f32).sin() * fade;
                            // Use a sawtooth wave instead of a sine wave.
                            sample += sawtooth_wave(*freq / 2.0, n / channels as usize, sample_rate, channels) * fade;
                        }
                        sample /= frequencies.len() as f32;
                        // writer.write_sample(sample)?;
                        samples.push(sample);
                    }
                    

                    beat += duration;
                }
                None => break,
            }
        }

        samples
    }
}

impl Timed for Song {
    fn duration(&self) -> f32 {
        self.melody.duration().max(self.chords.duration())
    }
}

impl Add<Song> for Song {
    type Output = Song;

    fn add(mut self, other: Song) -> Song {
        self.pad_with_rests();
        self.melody.extend(other.melody);
        self.harmony.extend(other.harmony);
        self.chords.extend(other.chords);
        self.pad_with_rests();
        self.tempo = self.tempo.max(other.tempo);
        self
    }
}

impl AddAssign<Song> for Song {
    fn add_assign(&mut self, other: Song) {
        self.pad_with_rests();
        self.melody.extend(other.melody);
        self.harmony.extend(other.harmony);
        self.chords.extend(other.chords);
        self.pad_with_rests();
        self.tempo = self.tempo.max(other.tempo);
    }
}
